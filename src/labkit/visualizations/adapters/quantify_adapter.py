from pathlib import Path
from typing import List, Literal, Iterable
import xarray as xr
import json
import numpy as np
import plotly.express as px

def get_all_runs(experiment_path: Path) -> List[Path]:
    return [y for x in experiment_path.iterdir() if x.is_dir() for y in x.iterdir() if y.is_dir()]


def parse_run(run_path: Path):
    run_tuid = run_path.name

    # tuid格式如：20250516-041500-980-d7d72a-spectrum with qubit--gmonoff
    # 时间部分为前19位，随机字符串为第20到26位，label为第27位开始
    from datetime import datetime
    time_ = datetime.strptime(run_tuid[:19], "%Y%m%d-%H%M%S-%f")
    rand_str = run_tuid[20:26]
    run_name = run_tuid[27:]
    return {
        "time": time_,
        "random": rand_str,
        "run_name": run_name
    }


def get_dataset(run_path: Path) -> xr.Dataset:
    return xr.open_dataset(run_path / "dataset.hdf5")


def get_metadata(run_path: Path) -> dict:
    return clean_dict(json.load(open(run_path / "snapshot.json")))


def clean_dict(d):
    if not isinstance(d, dict):
        return d
    cleaned = {}
    for k, v in d.items():
        if k.startswith("_"):
            continue
        if v is None or v == {} or v == [] or v == "":
            continue
        if isinstance(v, dict):
            v = clean_dict(v)
            if v == {}:
                continue
        cleaned[k] = v
    return cleaned


def to_gridded_dataset(
    quantify_dataset: xr.Dataset,
    dimension: str = "dim_0",
    coords_names: Iterable | None = None,
) -> xr.Dataset:
    """Converts a flattened (a.k.a. "stacked") dataset as the one generated by the
    :func:`~initialize_dataset` to a dataset in which the measured values are mapped
    onto a grid in the `xarray` format.

    This will be meaningful only if the data itself corresponds to a gridded
    measurement.

    .. note::

        Each individual :code:`(x0[i], x1[i], x2[i], ...)` setpoint must be unique.

    Conversions applied:

    - The names :code:`"x0", "x1", ...` will correspond to the names of the Dimensions.
    - The unique values for each of the :code:`x0, x1, ...` Variables are converted to
        Coordinates.
    - The :code:`y0, y1, ...` Variables are reshaped into a (multi-)dimensional grid
        and associated to the Coordinates.

    .. seealso::

        - :ref:`howto-data-handling-to-gridded`
        - :meth:`.MeasurementControl.setpoints_grid`

    Parameters
    ----------
    quantify_dataset
        Input dataset in the format generated by the :class:`~initialize_dataset`.
    dimension
        The flattened xarray Dimension.
    coords_names
        Optionally specify explicitly which Variables correspond to orthogonal
        coordinates, e.g. datasets holds values for :code:`("x0", "x1")` but only "x0"
        is independent: :code:`to_gridded_dataset(dset, coords_names=["x0"])`.

    Returns
    -------
    :
        The new dataset.
    """
    if dimension not in (dims := tuple(quantify_dataset.dims)):
        raise ValueError(f"Dimension {dimension} not in dims {dims}.")

    if coords_names is None:
        # for compatibility with older datasets we use `variables` instead of `coords`
        coords_names = sorted(
            v for v in quantify_dataset.variables if v.startswith("x")
        )
    else:
        for coord in coords_names:
            vars_ = tuple(quantify_dataset.variables.keys())
            if coord not in vars_:
                raise ValueError(f"Coordinate {coord} not in coordinates {vars_}.")

    # Because xarray in general creates new objects and
    # due to https://github.com/pydata/xarray/issues/2245
    # the attributes need to be saved and restored in the new object
    attrs_coords = tuple(quantify_dataset[name].attrs for name in coords_names)
    # Convert "xi" variables to Coordinates
    dataset = quantify_dataset.set_coords(coords_names)

    # Convert to a gridded xarray dataset format

    if len(coords_names) == 1:
        # No unstacking needed just swap the dimension
        for var in quantify_dataset.data_vars:
            if dimension in dataset[var].dims:
                dataset = dataset.update(
                    {var: dataset[var].swap_dims({dimension: coords_names[0]})},
                )
    else:
        # Make the Dimension `dimension` a MultiIndex(x0, x1, ...)
        dataset = dataset.set_index({dimension: coords_names})
        # See also: https://docs.xarray.dev/en/stable/reshaping.html#stack-and-unstack
        dataset = dataset.unstack(dim=dimension)
    for name, attrs in zip(coords_names, attrs_coords):
        dataset[name].attrs = attrs

    if "grid_2d" in dataset.attrs:
        dataset.attrs["grid_2d"] = False
    return dataset

def correct_phase_delay(
    phase_data: np.ndarray, 
    frequencies: np.ndarray, 
    delay_time: float, 
    phase_offset: float = 0.0
) -> np.ndarray:
    """
    Correct phase data for electrical delay and phase offset.
    
    Args:
        phase_data: Phase data array, can be 1D or 2D
        frequencies: Frequency array corresponding to phase measurements
        delay_time: Electrical delay time to correct for (in seconds)
        phase_offset: Additional phase offset to apply (default: 0.0)
    
    Returns:
        Phase-corrected data with same shape as input
    """
    # Ensure phase_data is 2D for consistent processing
    phase_2d = _ensure_2d_array(phase_data)
    
    # Pre-allocate output array
    corrected_phase = np.zeros_like(phase_2d)
    
    # Apply phase correction for each frequency point
    for i, freq in enumerate(frequencies):
        # Calculate phase correction: original + delay correction + offset
        corrected_value = (
            phase_2d[i] + 
            2 * np.pi * freq * delay_time + 
            phase_offset
        )
        
        # Wrap phase to [-π, π] range using complex exponential
        corrected_phase[i] = np.angle(np.exp(1j * corrected_value))
    
    # Return original dimensionality
    return _restore_original_shape(corrected_phase, phase_data.shape)


def _ensure_2d_array(arr: np.ndarray) -> np.ndarray:
    """Convert 1D array to 2D column vector, leave 2D arrays unchanged."""
    if arr.ndim == 1:
        return arr[:, np.newaxis]
    return np.array(arr)


def _restore_original_shape(arr_2d: np.ndarray, original_shape: tuple) -> np.ndarray:
    """Restore array to original shape if it was originally 1D."""
    if len(original_shape) == 1 and arr_2d.shape[1] == 1:
        return arr_2d.squeeze(axis=1)
    return arr_2d


def calculate_spectrum(
    dataset: xr.Dataset, 
    spectrum_type: str, 
    electrical_delay: float = 0.0
) -> xr.Dataset:
    """
    Calculate amplitude or phase spectrum from I/Q data.
    
    Args:
        dataset: xarray Dataset containing I/Q data pairs (y0, y1), (y2, y3), etc.
        spectrum_type: Type of spectrum to calculate - "amp" or "phase"
        electrical_delay: Electrical delay correction for phase (in seconds)
    
    Returns:
        New xarray Dataset with calculated spectrum data
        
    Raises:
        ValueError: If spectrum_type is not "amp" or "phase"
    """
    if spectrum_type not in ("amp", "phase"):
        raise ValueError("spectrum_type must be 'amp' or 'phase'")
    
    num_channels = _get_channel_count(dataset)
    
    if spectrum_type == "amp":
        data_vars = _calculate_amplitude_spectrum(dataset, num_channels)
    else:  # spectrum_type == "phase"
        data_vars = _calculate_phase_spectrum(dataset, num_channels, electrical_delay)
    
    return xr.Dataset(data_vars, attrs=dataset.attrs)


def _get_channel_count(dataset: xr.Dataset) -> int:
    """Get number of I/Q channels from dataset (assumes pairs of variables)."""
    return int(len(dataset.data_vars) / 2)


def _get_complex_signal(dataset: xr.Dataset, channel_idx: int) -> np.ndarray:
    """Extract complex signal from I/Q pair for given channel."""
    i_key = f"y{2 * channel_idx}"
    q_key = f"y{2 * channel_idx + 1}"
    return dataset[i_key].values + 1j * dataset[q_key].values


def _calculate_amplitude_spectrum(dataset: xr.Dataset, num_channels: int) -> dict:
    """Calculate amplitude spectrum in dB for all channels."""
    data_vars = {}
    
    for channel in range(num_channels):
        complex_signal = _get_complex_signal(dataset, channel)
        amplitude_db = 20 * np.log10(np.abs(complex_signal))
        
        data_vars[f"amp{channel}"] = xr.DataArray(
            amplitude_db,
            coords=dataset.coords
        )
    
    return data_vars


def _calculate_phase_spectrum(
    dataset: xr.Dataset, 
    num_channels: int, 
    electrical_delay: float
) -> dict:
    """Calculate phase spectrum with delay correction for all channels."""
    data_vars = {}
    frequencies = dataset.x0.values
    
    for channel in range(num_channels):
        complex_signal = _get_complex_signal(dataset, channel)
        raw_phase = np.angle(complex_signal)
        
        # Apply phase correction using the refactored function
        corrected_phase = correct_phase_delay(
            raw_phase, 
            frequencies, 
            electrical_delay
        )
        
        data_vars[f"phase{channel}"] = xr.DataArray(
            corrected_phase,
            coords=dataset.coords
        )
    
    return data_vars

def draw_figure(dset, type: Literal["amp", "phase", "real", "imag", "power", "original"]="original", elec_delay=0):
    if "x1" not in dset:
        return draw_1d_figure(dset, type, elec_delay)
    else:   
        if "grid_2d" in dset.attrs and dset.attrs["grid_2d"]:
            dset = to_gridded_dataset(dset)
        return draw_2d_figure(dset, type, elec_delay)

def draw_2d_figure(dset: xr.Dataset, type: Literal["amp", "phase", "real", "imag", "power", "original"]="original", elec_delay=0):
    dset_new = None
    if type == "amp":
        dset_new = calculate_spectrum(dset, "amp")
    elif type == "phase":
        dset_new = calculate_spectrum(dset, "phase", electrical_delay=elec_delay)
    elif type == "original":
        dset_new = dset.copy(True)
    else:
        raise ValueError("type must be one of amp, phase, original")
    
    for dvar in dset_new.data_vars.keys():
        y = dset_new[dvar].values
        # _t1 = y - y.mean(axis=1, keepdims=True)
        # dset_new[dvar] = xr.DataArray(y - 0*y.mean(axis=0, keepdims=True), coords=dset_new.coords)
        # dset_new[dvar] = xr.DataArray(_t1 - _t1.mean(axis=0, keepdims=True), coords=dset_new.coords)
        dset_new[dvar] = xr.DataArray(y, coords=dset_new.coords)

    return [
        px.imshow(
                    dset_new[key].values,
                    x=dset_new.x1.values,
                    y=dset_new.x0.values,
                    aspect="auto",
                    origin="lower",
                    color_continuous_scale="RdBu",
                    # color_continuous_scale="hot",
                    title=dset_new.attrs["name"],
                    labels={
                        "x": dset_new.x1.attrs["long_name"] if "long_name" in dset_new.x1.attrs else "x1",
                        "y": dset_new.x0.attrs["long_name"] if "long_name" in dset_new.x0.attrs else "x0"
                    }
                )
            # dset_amp.hvplot.image(x="x1", y="x0", z=str(key), dynamic=False, cmap="bwr")
            for key in dset_new.data_vars.keys()
    ]


def draw_1d_figure(dset: xr.Dataset, type: Literal["amp", "phase", "real", "imag", "power", "original"]="original", elec_delay=0,):
    dset_new = None
    if len(list(dset.data_vars.keys())) == 1:
        print(len(list(dset.coords.keys())))
        type = "original"
    
    if type == "amp":
        dset_new = calculate_spectrum(dset, "amp")
    elif type == "phase":
        dset_new = calculate_spectrum(dset, "phase", electrical_delay=elec_delay)
    elif type == "original":
        dset_new = dset.copy(True)
    else:
        raise ValueError("type must be one of amp, phase, original")

    return [ px.line(
            x=dset.x0.values,
            y=y,

        )
     for y in dset_new.data_vars.values()]

def spec_draw_amp(dset: xr.Dataset):
    _dset = calculate_spectrum(dset, "amp")
    
    # return a graph list
    return [ px.imshow(
                    _dset[key].values,
                    x=_dset.x1.values,
                    y=_dset.x0.values,
                    aspect="auto",
                    origin="lower",
                    color_continuous_scale="RdBu",
                    # color_continuous_scale="hot",
                    title=_dset.attrs["name"]

                )
            # dset_amp.hvplot.image(x="x1", y="x0", z=str(key), dynamic=False, cmap="bwr")
            for key in _dset.data_vars.keys()
        ]



def spec_draw_phase(dset: xr.Dataset, elec_delay=0):
    _dset = calculate_spectrum(dset, "phase", electrical_delay=elec_delay)

    # return a graph list
    return [px.imshow(
                    _dset[key].values,
                    x=_dset.x1.values,
                    y=_dset.x0.values,
                    aspect="auto",
                    origin="lower",
                    color_continuous_scale="RdBu",
                    title=_dset.attrs["name"]
                )
            for key in _dset.data_vars.keys()
        ]











# def spec_draw_widget_amp(dset: xr.Dataset):
#     _dset = calculate_spectrum(dset, "amp")
#     _dset = dset.copy(True)

#     # return a graph list
#     return html.Div(
#         [
#             heatmap_crange_cmap(_dset, key)
#             for key in _dset.data_vars.keys()
#         ],
#         className="flex flex-row"
#     )


# def spec_draw_widget_phase(dset: xr.Dataset, elec_delay=0):
#     _dset = calculate_spectrum(dset, "phase", electrical_delay=elec_delay)
#     _dset = dset.copy(True)
#     # for dvar in _dset.data_vars.keys():
#     #     y = _dset[dvar].values
#     #     _dset[dvar] = xarray.DataArray(y - y.mean(axis=0, keepdims=True), coords=_dset.coords)

#     # return a graph list
#     return html.Div(
#         [
#             heatmap_crange_cmap(_dset, key)
#             for key in _dset.data_vars.keys()
#         ],
#         className="flex flex-row"
#     )



# def heatmap_crange_cmap(dset_grid, data_var="y0", cmap="RdBu"):
#     dset_hash = hash(np.random.random())
#     cmap_selector = dmc.Select(
#         # className="",
#         label="Color map",
#         id={"type": "cs_id", "index": dset_hash},
#         value=cmap,
#         data=[
#             "Blackbody",
#             "Bluered",
#             "Blues",
#             "Cividis",
#             "Earth",
#             "Electric",
#             "Greens",
#             "Greys",
#             "Hot",
#             "Jet",
#             "Picnic",
#             "Portland",
#             "Rainbow",
#             "RdBu",
#             "Reds",
#             "Viridis",
#             "YlGnBu",
#             "YlOrRd",
#         ],
#     )
#     low, high = np.floor(np.nanmin(dset_grid[data_var].data)), np.ceil(np.nanmax(dset_grid[data_var].data))
#     color_bar_range = dcc.RangeSlider(
#         # className="",
#         id={"type": "cbr_id", "index": dset_hash},
#         value=[low, high],
#         min=   low ,
#         max=high,
#     )
    

#     # 
#     _fig = px.imshow(
#             dset_grid[data_var].values,
#             x=dset_grid.x1.values,
#             y=dset_grid.x0.values,
#             aspect="auto",
#             origin="lower",
#             color_continuous_scale=cmap,
#         )
#     _fig.update_layout(
#         xaxis_title=rf"{dset_grid.x1.attrs['long_name']} ({dset_grid.x1.attrs['units']})",
#         yaxis_title=rf"{dset_grid.x0.attrs['long_name']} ({dset_grid.x0.attrs['units']})",
#         title=dset_grid.attrs["name"],
#     )
#     #
#     line_data = pd.DataFrame(dset_grid[data_var].values.T, columns=dset_grid.x0.values)
#     line_data['x1'] = np.round(dset_grid.x1.values,2)
#     line_data = line_data.melt(id_vars=['x1'], var_name='X Range', value_name='Value')
#     _fig1 = px.line(
#         line_data, 
#         x='X Range', 
#         y='Value', 
#         color='x1', 
#         title="Line Plot of dB Data vs X Range",
#         labels={'qB_x1amp': 'qB_xy_amp'}
#     )

#     graph = dcc.Graph(
#         id={"type": "graph_id", "index": dset_hash},
#         figure=_fig
#     )
#     graph1 = dcc.Graph(
#         id={"type": "graph_id1", "index": dset_hash},
#         figure=_fig1
#     )
#     dset_var_store = dcc.Store(id={"type": "dv_id", "index": dset_hash}, data=data_var)

#     return html.Div(
#         [dset_var_store, graph, color_bar_range, cmap_selector,graph1], className="w-[40rem]"
#     )
